<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="hello world"><title>Android--Activity组件 | SunnyBird' s Space</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android--Activity组件</h1><a id="logo" href="/.">SunnyBird' s Space</a><p class="description">大道至简，知易行难</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android--Activity组件</h1><div class="post-meta">Feb 20, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p><a href="http://www.cnblogs.com/lyp3314/archive/2011/11/10/2244971.html" target="_blank" rel="external">总结自互联网</a></p>
<h3 id="一、什么是activity"><a href="#一、什么是activity" class="headerlink" title="一、什么是activity"></a>一、什么是activity</h3><p>Activity 是用户接口程序，原则上它会提供给用户一个交互式的接口功能。它是 android 应用程序的基本功能单元。Activity 本身是没有界面的。所以activity类创建了一个窗口，开发人员可以通过setContentView(View)接口把UI放到activity创建的窗口上，当activity指向全屏窗口时，也可以用其他方式实现：作为漂浮窗口（通过windowIsFloating的主题集合），或者嵌入到其他的activity（使用ActivityGroup）。activity是单独的，用于处理用户操作。几乎所有的activity都要和用户打交道。</p>
<h3 id="二、activity生命周期"><a href="#二、activity生命周期" class="headerlink" title="二、activity生命周期"></a>二、activity生命周期</h3><p><img src="http://pic002.cnblogs.com/images/2011/309948/2011111019573521.png" alt="摘自 Google 官网"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由图可知：<br>在一个Activity正常启动过程中，这些方法调用的顺序是onCreate -&gt; onStart -&gt; onResume；在Activity被kill掉的时候方法顺序是onPause -&gt; onStop -&gt; onDestroy，此为一个完整的Lifecycle。那么对于中断处理（比如电话来了），则是onPause -&gt; onStop，恢复时onStart -&gt; onResume；如果当前应用程序的是一个Theme为Translucent（半透明） 或者Dialog 的Activity那么中断就是onPause ,恢复的时候onResume。</p>
<p>那么对于”Other app need memory”，就是我们手机在运行一个应用程序的时候，有可能打进来电话发进来短信，或者没有电了，这时候程序都会被中断，优先去服务电话的基本功能，另外系统也不允许你占用太多资源，至少要保证一些功能（比如电话）,所以资源不足的时候也就有可能被kill掉。</p>
<p>方法在系统中的作用及我们应该做什么：<br>　　onCreate：在这里创建界面，做一些数据的初始化工作；<br>　　onStart： 到这一步变成“用户可见不可交互”的状态；<br>　　onResume：变成和用户可交互的，(在Activity栈系统通过栈的方式管理这些Activity，即当前Activity在栈的最上端，运行完弹出栈，则回到上一个Activity)；<br>　　onPause：到这一步是可见但不可交互的，系统会停止动画等消耗CPU的事情。从上文的描述已经知道，应该在这里保存你的一些数据,因为这个时候你的程序的优先级降　　　　　　　　  低，有可能被系统收回。在这里保存的数据，应该在onResume里读出来。<br>　　onStop：变得不可见 ，被下一个activity覆盖了<br>　　onDestroy：这是Activity被kill前最后一个被调用方法了，可能是其他类调用finish方法或者是系统为了节省空间将它暂时性的干掉，可以用isFinishing()来判断它，如果你有　　　　　　        一个Progress Dialog在线程中运行，请在onDestroy里把他cancel掉，不然等线程结束的时候，调用Dialog的cancel方法会抛异常。<br>onPause，onstop， onDestroy，三种状态下 activity都有可能被系统kill 掉。</p>
<h3 id="三、Activity之间的通信"><a href="#三、Activity之间的通信" class="headerlink" title="三、Activity之间的通信"></a>三、Activity之间的通信</h3><p>在 Android 中，不同的 Activity 实例可能运行在一个进程中，也可能运行在不同的进程中。因此我们需要一种特别的机制帮助我们在 Activity 之间传递消息。Android 中通过 Intent 对象来表示一条消息，一个 Intent 对象不仅包含有这个消息的目的地，还可以包含消息的内容，这好比一封 Email，其中不仅应该包含收件地址，还可以包含具体的内容。对于一个 Intent 对象，消息“目的地”是必须的，而内容则是可选项。</p>
<p>Intent负责对操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。因此，Intent在这里起着一个媒体中介的作用，专门提供组件互相调用的相关信息，实现调用者与被调用者之间的解耦。</p>
<p>在应用中，我们可以以两种形式来使用Intent：</p>
<ul>
<li>直接Intent：指定了component属性的Intent（调用setComponent(ComponentName)或者setClass(Context, Class)来指定）。通过指定具体的组件类，通知应用启动对应的组件。</li>
<li>间接Intent：没有指定comonent属性的Intent。这些Intent需要包含足够的信息，这样系统才能根据这些信息，在在所有的可用组件中，确定满足此Intent的组件。</li>
</ul>
<p>对于直接Intent，Android不需要去做解析，因为目标组件已经很明确。<br>Android需要解析的是那些间接Intent，通过解析，将 Intent映射给可以处理此Intent的Activity、IntentReceiver或Service。Intent解析机制主要是通过查找已注册在AndroidManifest.xml中的所有IntentFilter及其中定义的Intent，最终找到匹配的Intent。
　　</p>
<h3 id="四、Activity-的-Intent-Filter"><a href="#四、Activity-的-Intent-Filter" class="headerlink" title="四、Activity 的 Intent Filter"></a>四、Activity 的 Intent Filter</h3><p>Intent Filter 描述了一个组件愿意接收什么样的 Intent 对象，Android 将其抽象为 android.content.IntentFilter 类。在 Android 的 AndroidManifest.xml 配置文件中可以通过 <intent-filter>节点为一个 Activity 指定其 Intent Filter，以便告诉系统该 Activity 可以响应什么类型的 Intent。<br>当使用 startActivity(intent) 来启动另外一个 Activity 时，如果直接指定 intent 对象的 Component 属性，那么 Activity Manager 将试图启动其 Component 属性指定的 Activity。否则 Android 将通过 Intent 的其它属性从安装在系统中的所有 Activity 中查找与之最匹配的一个启动，如果没有找到合适的 Activity，应用程序会得到一个系统抛出的异常。这个匹配的过程如下：<br><img src="http://pic002.cnblogs.com/images/2011/309948/2011111020310927.jpg" alt="">　　</intent-filter></p>
<h3 id="五、Activity的栈式管理"><a href="#五、Activity的栈式管理" class="headerlink" title="五、Activity的栈式管理"></a>五、Activity的栈式管理</h3><p>Android针对Activity的管理使用的是栈，就是说某一个时刻只有一个Activity处在栈顶，当这个Activity被销毁后，下面的Activity才有可能浮到栈顶，或者有一个新的Activity被创建出来，则旧的Activity就被压栈沉下去了。Activity是Android程序的表现层。程序的每一个显示屏幕就是一个Activity。正在运行的Activity处在栈的最顶端，它是运行状态的。<br><img src="http://pic002.cnblogs.com/images/2011/309948/2011111020580512.jpg" alt=""><br>当在程序中调用 Activity.finish()方法时，结果和用户按下 BACK 键一样：它告诉 Activity Manager该Activity实例可以被“回收”。随后 Activity Manager 激活处于栈第二层的 Activity ，把原 Activity 压入到栈的第二层，从 Running 状态转到 Paused 状态。</p>
<h3 id="六、Activity的加载模式"><a href="#六、Activity的加载模式" class="headerlink" title="六、Activity的加载模式"></a>六、Activity的加载模式</h3><p>standard、singleTop、singleTask、singleInstance(其中前两个是一组、后两个是一组)，默认为standard </p>
<ol>
<li>standard：就是intent将发送给新的实例，所以每次跳转都会生成新的activity。</li>
<li>singleTop：也是发送新的实例，但不同standard的一点是，在请求的Activity正好位于栈顶时(配置成singleTop的Activity)，不会构造新的实例</li>
<li>singleTask：和后面的singleInstance都只创建一个实例，当intent到来，需要创建设置为singleTask的Activity的时候，系统会检查栈里面是否已经有该Activity的实例。如果有直接将intent发送给它。</li>
<li>singleInstance：首先说明一下task这个概念，Task可以认为是一个栈，可放入多个Activity。比如启动一个应用，那么Android就创建了一个Task，然后启动这个应用的入口Activity，那在它的界面上调用其他的Activity也只是在这个task里面。那如果在多个task中共享一个Activity的话怎么办呢。举个例来说，如果开启一个导游服务类的应用程序，里面有个Activity是开启GOOGLE地图的，当按下home键退回到主菜单又启动GOOGLE地图的应用时，显示的就是刚才的地图，实际上是同一个Activity，实际上这就引入了singleInstance。singleInstance模式就是将该Activity单独放入一个栈中，这样这个栈中只有这一个Activity，不同应用的intent都由这个Activity接收和展示，这样就做到了共享。当然前提是这些应用都没有被销毁，所以刚才是按下的HOME键，如果按下了返回键，则无效。</li>
</ol>
<h3 id="七、Activity的跳转"><a href="#七、Activity的跳转" class="headerlink" title="七、Activity的跳转"></a>七、Activity的跳转</h3><p>Activity跳转，无返回结果<br>这是最简单的Activity跳转方式。从一个Activity启动另一个Activity，直接startActivity(new Intent(当前Activity.this, 下一Activity.class))。</p>
<p>Activity跳转，返回数据/结果<br>需要返回数据或结果的，则使用startActivityForResult (Intent intent, int requestCode)，requestCode的值是自定义的，用于识别跳转的目标Activity。跳转的目标Activity所要做的就是返回数据/结果，setResult(int resultCode)只返回结果不带数据，或者setResult(int resultCode, Intent data)两者都返回！而接收返回的数据/结果的处理函数是onActivityResult(int requestCode, int resultCode, Intent data)，这里的requestCode就是startActivityForResult的requestCode，resultCode就是setResult里面的resultCode，返回的数据在data里面。</p>
<p><strong>注意，在setResult后，要调用finish()销毁当前的Activity，否则无法返回到原来的Activity，就无法执行原来Activity的onActivityResult函数，看到当前的Activity没反应</strong></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2017/02/20/Android-Activity组件/" data-id="cj1i3ejtx0000fh0xcg4thygg" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/2016/08/11/Android-App退出方案/" class="pre">Android--App退出方案</a><a href="/2017/03/15/Android-网络通信方式/" class="next">Android--网络通信方式</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/tools/" style="font-size: 15px;">tools</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/04/14/基于Android平台编译FFmpeg-3-2-4/">基于Android平台编译FFmpeg-3.2.4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/11/Android平台可执行二进制程序/">Android平台可执行二进制程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/02/Android加壳那些事/">Android加壳那些事</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/15/Android-网络通信方式/">Android--网络通信方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/20/Android-Activity组件/">Android--Activity组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/11/Android-App退出方案/">Android--App退出方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/26/Android-RadioButton实践/">Android-RadioButton实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/02/Android-Service组件/">Android--Service组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/17/Android5.1兼容flash方案/">Android5.1兼容flash方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/22/Android中自定义通知声音/">Android中自定义通知声音</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/jinlongfeng123" title="Sunny@CSDN" target="_blank">Sunny@CSDN</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">SunnyBird' s Space.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>